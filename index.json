[{"authors":["admin"],"categories":null,"content":"I\u0026rsquo;m receiving my Master’s degree in Computer Science this coming May and am currently looking for employment opportunities. While receiving my education from the University of Kentucky and Purdue University I had multiple internships where I worked as a software engineer, malware analyst, and researcher.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://davidmitchelperry.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"I\u0026rsquo;m receiving my Master’s degree in Computer Science this coming May and am currently looking for employment opportunities. While receiving my education from the University of Kentucky and Purdue University I had multiple internships where I worked as a software engineer, malware analyst, and researcher.","tags":null,"title":"David M. Perry","type":"author"},{"authors":["David Perry","Dohyeong Kim","Roopsha Samanta","Xiangyu Zhang"],"categories":null,"content":"","date":1555961954,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555961954,"objectID":"1edfb1016555bbd5681af0982466e8d1","permalink":"https://davidmitchelperry.github.io/publication/semcluster-clustering-of-imperative-programming-assignments-based-on-quantitative-semantic-features/","publishdate":"2019-04-22T15:39:14-04:00","relpermalink":"/publication/semcluster-clustering-of-imperative-programming-assignments-based-on-quantitative-semantic-features/","section":"publication","summary":"A fundamental challenge in automated reasoning about programming assignments at\nscale is clustering student submissions based on their underlying algorithms.\nState-of-the-art clustering techniques are sensitive to control structure \nvariations, cannot cluster buggy solutions with similar correct solutions, and\neither require expensive pair-wise program analyses or training efforts. We\npropose a novel technique that can cluster small imperative programs based on\ntheir algorithmic essence: (A) how the input space is partitioned into\nequivalence classes and (B) how the problem is uniquely addressed within\nindividual equivalence classes. We capture these algorithmic aspects as two\nquantitative semantic program features that are merged into a program’s vector\nrepresentation. Programs are then clustered using their vector\nrepresentations. The computation of our first semantic feature leverages model\ncounting to identify the number of inputs belonging to an input equivalence\nclass. The computation of our second semantic feature abstracts the pro-\ngram’s data flow by tracking the number of occurrences of a unique pair of\nconsecutive values of a variable during its lifetime. The comprehensive\nevaluation of our tool SemCluster on benchmarks drawn from solutions to small\nprogramming assignments shows that SemCluster (1) generates far fewer\nclusters than other clustering techniques, (2) precisely identifies distinct\nsolution strategies, and (3) boosts the performance of clustering-based program\nrepair, all within a reasonable amount of time.\n","tags":null,"title":"SemCluster: Clustering of Imperative Programming Assignments Based on Quantitative Semantic Features","type":"publication"},{"authors":["Wei You","Xuwei Liu","Shiqing Ma","David Perry","Xiangyu Zhang","Bin Lang"],"categories":null,"content":"","date":1555961501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555961501,"objectID":"d917ebf297f76f90f31a264effe32ecd","permalink":"https://davidmitchelperry.github.io/publication/slf-fuzzing-without-valid-seed-inputs/","publishdate":"2019-04-22T15:31:41-04:00","relpermalink":"/publication/slf-fuzzing-without-valid-seed-inputs/","section":"publication","summary":"Fuzzing is an important technique to detect software\nbugs   and   vulnerabilities.   It   works   by   mutating   a   small   set\nof   seed   inputs   to   generate   a   large   number   of   new   inputs.\nFuzzers’  performance  often  substantially  degrades  when  valid\nseed inputs are not available. Although existing techniques such\nas  symbolic  execution  can  generate  seed  inputs  from  scratch,\nthey  have  various  limitations  hindering  their  applications  in\nreal-world  complex  software.  In  this  paper,  we  propose  a  novel\nfuzzing technique that features the capability of generating valid\nseed  inputs.  It  piggy-backs  on  AFL  to  identify  input  validity\nchecks  and  the  input  fields  that  have  impact  on  such  checks.\nIt  further  classifies  these  checks  according  to  their  relations  to\nthe input. Such classes include arithmetic relation, object offset,\ndata  structure  length  and  so  on.  A  multi-goal  search  algorithm\nis developed to apply class-specific mutations in order to satisfy\ninter-dependent  checks  all  together.  We  evaluate  our  technique\non 20 popular benchmark programs collected from other fuzzing\nprojects  and  the  Google  fuzzer  test  suite,  and  compare  it  with\nexisting  fuzzers  AFL  and  AFLFast,  symbolic  execution  engines\nKLEE and S2E, and a hybrid tool Driller that combines fuzzing\nwith symbolic execution. The results show that our technique is\nhighly  effective  and  efficient,  out-performing  the  other  tools. \n","tags":[],"title":"SLF: Fuzzing Without Valid Seed Inputs","type":"publication"},{"authors":["Jianjun Huang","Yousra Aafer","David Perry","Xiangyu Zhang","Chen Tian"],"categories":null,"content":"","date":1510083049,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1510083049,"objectID":"dfa4f73071a1927cd5c4cb27813d2909","permalink":"https://davidmitchelperry.github.io/publication/ui-driven-android-application-reduction/","publishdate":"2017-11-07T14:30:49-05:00","relpermalink":"/publication/ui-driven-android-application-reduction/","section":"publication","summary":"While smartphones and mobile apps have been an integral part of our life,\nmodern mobile apps tend to contain a lot of rarely used functionalities. For\nexample, applications contain advertisements and offer extra features such as\nrecommended news stories in weather apps. While these functionalities are not\nessential to an app, they nonetheless consume power, CPU cycles and bandwidth.\nIn this paper, we design a UI driven approach that allows customizing an\nAndroid app by removing its unwanted functionalities. In particular, our\ntechnique displays the UI and allows the user to select elements denoting\nfunctionalities that she wants to remove. Using this information, our technique\nautomatically removes all the code elements related to the selected\nfunctionalities, including all the relevant background tasks. The underlying\nanalysis is a type system, in which each code element is tagged with a type\nindicating if it should be removed. From the UI hints, our technique infers\ntypes for all other code elements and reduces the app accordingly. We implement\na prototype and evaluate it on 10 real-world Android apps. The results show\nthat our approach can accurately discover the removable code elements and lead\nto substantial resource savings in the reduced apps.\n","tags":[],"title":"UI Driven Android Application Reduction","type":"publication"},{"authors":["David Perry","Andrea Mattavelli","Xiangyu Zhang","Cristian Cadar"],"categories":null,"content":"","date":1499455654,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1499455654,"objectID":"243af8619a2634b1979a32b15b336b9c","permalink":"https://davidmitchelperry.github.io/publication/accelerating-array-constraints-in-symbolic-execution/","publishdate":"2017-07-07T14:27:34-05:00","relpermalink":"/publication/accelerating-array-constraints-in-symbolic-execution/","section":"publication","summary":"Despite significant recent advances, the effectiveness of symbolic execution is\nlimited when used to test complex, real-world software.  One of the main\nscalability challenges is related to constraint solving: large applications and\nlong exploration paths lead to complex constraints, often involving big arrays\nindexed by symbolic expressions.  In this paper, we propose a set of\nsemantics-preserving transformations for array operations that take advantage\nof contextual information collected during symbolic execution. Our\ntransformations lead to simpler encodings and hence better performance in\nconstraint solving. The results we obtain are encouraging: we show, through an\nextensive experimental analysis, that our transformations help to significantly\nimprove the performance of symbolic execution in the presence of arrays. We\nalso show that our transformations enable the analysis of new code, which would\nbe otherwise out of reach for symbolic execution.\n","tags":[],"title":"Accelerating Array Constraints in Symbolic Execution","type":"publication"},{"authors":["Dohyeong Kim","Yonghwi Kwon","Peng Liu","I Luk Kim","David Mitchel Perry","Xiangyu Zhang","Gustavo Rodrigues-Rivera"],"categories":null,"content":"","date":1478546288,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1478546288,"objectID":"8a810d521224ab4c7f48022ba02c3eb7","permalink":"https://davidmitchelperry.github.io/publication/apex-automatic-programming-assignment-error-explanation/","publishdate":"2016-11-07T14:18:08-05:00","relpermalink":"/publication/apex-automatic-programming-assignment-error-explanation/","section":"publication","summary":"This paper presents Apex, a system that can automatically generate explanations\nfor programming assignment bugs, regarding where the bugs are and how the root\ncauses led to the runtime failures. It works by comparing the passing execution\nof a correct implementation (provided by the instructor) and the failing\nexecution of the buggy implementation (submitted by the student). The technique\novercomes a number of technical challenges caused by syntactic and semantic\ndifferences of the two implementations. It collects the symbolic traces of the\nexecutions and matches assignment statements in the two execution traces by\nreasoning about symbolic equivalence. It then matches predicates by aligning\nthe control dependences of the matched assignment statements, avoiding direct\nmatching of path conditions which are usually quite different. Our evaluation\nshows that Apex is every effective for 205 buggy real world student submissions\nof 4 programming assignments, and a set of 15 programming assignment type of\nbuggy programs collected from stackoverflow.com, precisely pinpointing the root\ncauses and capturing the causality for 94.5% of them. The evaluation on a\nstandard benchmark set with over 700 student bugs shows similar results. A user\nstudy in the classroom shows that Apex has substantially improved student\nproductivity.\n","tags":[],"title":"Apex: Automatic Programming Assignment Error Explanation","type":"publication"}]