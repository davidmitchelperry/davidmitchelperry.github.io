[{"authors":["admin"],"categories":null,"content":"I\u0026rsquo;m receiving my Master’s degree in Computer Science this coming May and am currently looking for employment opportunities. While receiving my education from the University of Kentucky and Purdue University I had multiple internships where I worked as a software engineer, malware analyst, and researcher.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://davidmitchelperry.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"I\u0026rsquo;m receiving my Master’s degree in Computer Science this coming May and am currently looking for employment opportunities. While receiving my education from the University of Kentucky and Purdue University I had multiple internships where I worked as a software engineer, malware analyst, and researcher.","tags":null,"title":"David M. Perry","type":"author"},{"authors":["David Perry","Dohyeong Kim","Roopsha Samanta","Xiangyu Zhang"],"categories":null,"content":"","date":1555961954,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555961954,"objectID":"1edfb1016555bbd5681af0982466e8d1","permalink":"https://davidmitchelperry.github.io/publication/semcluster-clustering-of-imperative-programming-assignments-based-on-quantitative-semantic-features/","publishdate":"2019-04-22T15:39:14-04:00","relpermalink":"/publication/semcluster-clustering-of-imperative-programming-assignments-based-on-quantitative-semantic-features/","section":"publication","summary":"A fundamental challenge in automated reasoning about pro-\ngramming assignments at scale is clustering student submis-\nsions based on their underlying algorithms. State-of-the-art\nclustering techniques are sensitive to control structure vari-\nations, cannot cluster buggy solutions with similar correct\nsolutions, and either require expensive pair-wise program\nanalyses or training efforts. We propose a novel technique\nthat can cluster small imperative programs based on their\nalgorithmic essence: (A) how the input space is partitioned\ninto equivalence classes and (B) how the problem is uniquely\naddressed within individual equivalence classes. We cap-\nture these algorithmic aspects as two quantitative semantic\nprogram features that are merged into a program’s vector\nrepresentation. Programs are then clustered using their vec-\ntor representations. The computation of our first semantic\nfeature leverages model counting to identify the number of\ninputs belonging to an input equivalence class. The com-\nputation of our second semantic feature abstracts the pro-\ngram’s data flow by tracking the number of occurrences\nof a unique pair of consecutive values of a variable dur-\ning its lifetime. The comprehensive evaluation of our tool\nSemCluster on benchmarks drawn from solutions to small\nprogramming assignments shows that SemCluster (1) gen-\nerates far fewer clusters than other clustering techniques,\n(2) precisely identifies distinct solution strategies, and (3)\nboosts the performance of clustering-based program repair,\nall within a reasonable amount of time.\n","tags":[],"title":"SemCluster: Clustering of Imperative Programming Assignments Based on Quantitative Semantic Features","type":"publication"},{"authors":["Wei You","Xuwei Liu","Shiqing Ma","David Perry","Xiangyu Zhang","Bin Lang"],"categories":null,"content":"","date":1555961501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555961501,"objectID":"d917ebf297f76f90f31a264effe32ecd","permalink":"https://davidmitchelperry.github.io/publication/slf-fuzzing-without-valid-seed-inputs/","publishdate":"2019-04-22T15:31:41-04:00","relpermalink":"/publication/slf-fuzzing-without-valid-seed-inputs/","section":"publication","summary":"Fuzzing is an important technique to detect software\nbugs   and   vulnerabilities.   It   works   by   mutating   a   small   set\nof   seed   inputs   to   generate   a   large   number   of   new   inputs.\nFuzzers’  performance  often  substantially  degrades  when  valid\nseed inputs are not available. Although existing techniques such\nas  symbolic  execution  can  generate  seed  inputs  from  scratch,\nthey  have  various  limitations  hindering  their  applications  in\nreal-world  complex  software.  In  this  paper,  we  propose  a  novel\nfuzzing technique that features the capability of generating valid\nseed  inputs.  It  piggy-backs  on  AFL  to  identify  input  validity\nchecks  and  the  input  fields  that  have  impact  on  such  checks.\nIt  further  classifies  these  checks  according  to  their  relations  to\nthe input. Such classes include arithmetic relation, object offset,\ndata  structure  length  and  so  on.  A  multi-goal  search  algorithm\nis developed to apply class-specific mutations in order to satisfy\ninter-dependent  checks  all  together.  We  evaluate  our  technique\non 20 popular benchmark programs collected from other fuzzing\nprojects  and  the  Google  fuzzer  test  suite,  and  compare  it  with\nexisting  fuzzers  AFL  and  AFLFast,  symbolic  execution  engines\nKLEE and S2E, and a hybrid tool Driller that combines fuzzing\nwith symbolic execution. The results show that our technique is\nhighly  effective  and  efficient,  out-performing  the  other  tools. \n","tags":[],"title":"SLF: Fuzzing Without Valid Seed Inputs","type":"publication"},{"authors":["Jianjun Huang","Yousra Aafer","David Perry","Xiangyu Zhang","Chen Tian"],"categories":null,"content":"","date":1510083049,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1510083049,"objectID":"dfa4f73071a1927cd5c4cb27813d2909","permalink":"https://davidmitchelperry.github.io/publication/ui-driven-android-application-reduction/","publishdate":"2017-11-07T14:30:49-05:00","relpermalink":"/publication/ui-driven-android-application-reduction/","section":"publication","summary":"While smartphones and mobile apps have been an integral part of our life, modern mobile apps tend to contain a lot of rarely used functionalities. For example, applications contain advertisements and offer extra features such as recommended news stories in weather apps. While these functionalities are not essential to an app, they nonetheless consume power, CPU cycles and bandwidth. In this paper, we design a UI driven approach that allows customizing an Android app by removing its unwanted functionalities. In particular, our technique displays the UI and allows the user to select elements denoting functionalities that she wants to remove. Using this information, our technique automatically removes all the code elements related to the selected functionalities, including all the relevant background tasks. The underlying analysis is a type system, in which each code element is tagged with a type indicating if it should be removed. From the UI hints, our technique infers types for all other code elements and reduces the app accordingly. We implement a prototype and evaluate it on 10 real-world Android apps. The results show that our approach can accurately discover the removable code elements and lead to substantial resource savings in the reduced apps.","tags":[],"title":"UI Driven Android Application Reduction","type":"publication"},{"authors":["David Perry","Andrea Mattavelli","Xiangyu Zhang","Cristian Cadar"],"categories":null,"content":"","date":1499455654,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1499455654,"objectID":"243af8619a2634b1979a32b15b336b9c","permalink":"https://davidmitchelperry.github.io/publication/accelerating-array-constraints-in-symbolic-execution/","publishdate":"2017-07-07T14:27:34-05:00","relpermalink":"/publication/accelerating-array-constraints-in-symbolic-execution/","section":"publication","summary":"Despite significant recent advances, the effectiveness of symbolic execution is limited when used to test complex, real-world software.  One of the main scalability challenges is related to constraint solving: large applications and long exploration paths lead to complex constraints, often involving big arrays indexed by symbolic expressions.  In this paper, we propose a set of semantics-preserving transformations for array operations that take advantage of contextual information collected during symbolic execution. Our transformations lead to simpler encodings and hence better performance in constraint solving. The results we obtain are encouraging: we show, through an extensive experimental analysis, that our transformations help to significantly improve the performance of symbolic execution in the presence of arrays. We also show that our transformations enable the analysis of new code, which would be otherwise out of reach for symbolic execution.","tags":[],"title":"Accelerating Array Constraints in Symbolic Execution","type":"publication"},{"authors":["Dohyeong Kim","Yonghwi Kwon","Peng Liu","I Luk Kim","David Mitchel Perry","Xiangyu Zhang","Gustavo Rodrigues-Rivera"],"categories":null,"content":"","date":1478546288,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1478546288,"objectID":"8a810d521224ab4c7f48022ba02c3eb7","permalink":"https://davidmitchelperry.github.io/publication/apex-automatic-programming-assignment-error-explanation/","publishdate":"2016-11-07T14:18:08-05:00","relpermalink":"/publication/apex-automatic-programming-assignment-error-explanation/","section":"publication","summary":"This paper presents Apex, a system that can automatically generate explanations for programming assignment bugs, regarding where the bugs are and how the root causes led to the runtime failures. It works by comparing the passing execution of a correct implementation (provided by the instructor) and the failing execution of the buggy implementation (submitted by the student). The technique overcomes a number of technical challenges caused by syntactic and semantic differences of the two implementations. It collects the symbolic traces of the executions and matches assignment statements in the two execution traces by reasoning about symbolic equivalence. It then matches predicates by aligning the control dependences of the matched assignment statements, avoiding direct matching of path conditions which are usually quite different. Our evaluation shows that Apex is every effective for 205 buggy real world student submissions of 4 programming assignments, and a set of 15 programming assignment type of buggy programs collected from stackoverflow.com, precisely pinpointing the root causes and capturing the causality for 94.5% of them. The evaluation on a standard benchmark set with over 700 student bugs shows similar results. A user study in the classroom shows that Apex has substantially improved student productivity.","tags":[],"title":"Apex: Automatic Programming Assignment Error Explanation","type":"publication"}]